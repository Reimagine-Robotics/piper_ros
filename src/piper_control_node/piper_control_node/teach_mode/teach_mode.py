"""Teach mode via a custom gravity compensation mode.

The custom gravity compensation works by gathering a set of stable gravity
compensating torques using run_gather_data.py for various joint configurations.
These are then used to learn a torque residual function against a MUJOC model,
and this composite gravity model (MUJOCO + learned residual) is used to generate
on-the-fly gravity compensation torques for the Piper arm. These torques are
just enough to prevent the arm dropping from gravity, but any external force
applied (eg: a person moving the arm) will be enough to move the arm around
freely.
"""

from typing import Mapping, Sequence
import dataclasses
import json

import numpy as np

from piper_control import piper_interface
from piper_control import piper_control


@dataclasses.dataclass
class GravityTorqueSample:
  joint_configuration: np.ndarray
  joint_idx: int
  torque: float


def grav_comp_adjustment_fn(sim_torque, a, b, c, d):
  """A cubic adjustment of sim-predicted gravity torques."""
  return (
      a * sim_torque * sim_torque * sim_torque
      + b * sim_torque * sim_torque
      + c * sim_torque
      + d
  )


class _SimGravityTorquePrediction:
  """Predict gravity comp torques for the arm in any joint configuration."""

  def __init__(
      self,
      model_path: str,
      grav_comp_params: Mapping[int, Sequence[float]],
  ):
    # JIT import of mujoco to not force mujoco install for piper_ros users that
    # done use teach mode functionality.
    import mujoco

    self._model = mujoco.MjModel.from_xml_path(model_path)
    self._data = mujoco.MjData(self._model)
    self._mj_forward_fn = mujoco.mj_forward

    self._grav_comp_params = grav_comp_params

    joint_names = ["joint1", "joint2", "joint3", "joint4", "joint5", "joint6"]
    self._joint_ids = [self._model.joint(name).id for name in joint_names]

  def predict(self, joint_angles: Sequence[float]) -> Sequence[float]:
    assert len(joint_angles) == len(self._joint_ids)

    for i, joint_id in enumerate(self._joint_ids):
      self._data.qpos[joint_id] = joint_angles[i]
      self._data.qvel[:] = 0.0

    # Propagate the changes through the simulation
    self._mj_forward_fn(self._model, self._data)
    result = [self._data.qfrc_bias[ji] for ji in self._joint_ids]

    for i, predicted_torque in enumerate(result):
      if i in self._grav_comp_params:
        model_input = np.array(predicted_torque)
        params = self._grav_comp_params[i]
        result[i] = grav_comp_adjustment_fn(model_input, *params)

    assert len(result) == len(self._joint_ids)
    return result


def _load_sampled_gravity(
    filename: str,
) -> dict[int, Sequence[GravityTorqueSample]]:
  with open(filename, "r", encoding="utf-8") as f:
    serialised = json.load(f)

  result = {}
  for se in serialised:
    joint_idx = se["joint_idx"]

    if joint_idx not in result:
      result[joint_idx] = []

    result[joint_idx].append(
        GravityTorqueSample(
            joint_configuration=np.array(se["joints_cfg"]),
            joint_idx=joint_idx,
            torque=se["grav_comp_torque"],
        )
    )

  return result


def _compute_gravity_model(
    piper_model_path: str, grav_torques_file_path: str
) -> _SimGravityTorquePrediction:
  """Given sampled grav comp torques generated by run_gather_data.py, output a
  gravity model that uses both MUJOCO and a learned residual.
  """

  # JIT import of scipy to not force it on piper_ros users that dont use teach
  # mode functionality.
  from scipy import optimize

  real_gravity = _load_sampled_gravity(grav_torques_file_path)
  sim_gravity = _SimGravityTorquePrediction(piper_model_path, {})

  per_joint_params = {}

  for joint_idx, samples in real_gravity.items():
    real_torques = []
    sim_torques = []

    for sample in samples:
      real_torques.append(sample.torque)

      desired_angles = list(sample.joint_configuration)
      model_torques = sim_gravity.predict(desired_angles)

      model_torque = model_torques[joint_idx]
      sim_torques.append(np.array(model_torque))

    sim_torques = np.array(sim_torques)

    opt_params = optimize.curve_fit(
        grav_comp_adjustment_fn,
        sim_torques,
        real_torques,
        p0=[0.0, 0.0, 1.0, 0.0],
    )[0]

    per_joint_params[joint_idx] = opt_params

  return _SimGravityTorquePrediction(piper_model_path, per_joint_params)


class TeachController:
  """A controller that allows teach mode by commanding grav comp torques."""

  def __init__(
      self,
      robot: piper_interface.PiperInterface,
      controller: piper_control.MitJointPositionController,
      piper_model_path: str,
      grav_torques_file_path: str
  ):
    self._robot = robot
    self._controller = controller
    self._gravity_model = _compute_gravity_model(
        piper_model_path, grav_torques_file_path
    )

  def update_joint_feedback_torques(self, efforts: list[float]):
    self._joint_feedback_torques = efforts

  def step(self) -> None:
    cur_joints = self._robot.get_joint_positions()
    cur_vel = np.array(self._robot.get_joint_velocities())

    hover_torque = np.array(self._gravity_model.predict(cur_joints))

    # Stability torque acts to counteract joint movement. A dampener basically.
    stability_torque = -cur_vel * 1.0
    applied_torque = hover_torque + stability_torque

    if self._joint_feedback_torques is not None:
      applied_torque += self._joint_feedback_torques

    self._controller.command_torques(list(applied_torque))
