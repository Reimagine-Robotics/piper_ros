"""Teach mode via a custom gravity compensation mode.

The custom gravity compensation works by gathering a set of stable gravity
compensating torques using run_gather_data.py for various joint configurations.
These are then used to learn a torque residual function against a MUJOC model,
and this composite gravity model (MUJOCO + learned residual) is used to generate
on-the-fly gravity compensation torques for the Piper arm. These torques are
just enough to prevent the arm dropping from gravity, but any external force
applied (eg: a person moving the arm) will be enough to move the arm around
freely.
"""

import dataclasses
import json
from typing import Mapping, Sequence

import numpy as np
from piper_control import piper_control, piper_interface
from transformations import transformations as tr


@dataclasses.dataclass
class GravityTorqueSample:
  joint_configuration: np.ndarray
  joint_idx: int
  torque: float


def grav_comp_adjustment_fn(sim_torque, a, b, c, d):
  """A cubic adjustment of sim-predicted gravity torques."""
  return (
      a * sim_torque * sim_torque * sim_torque
      + b * sim_torque * sim_torque
      + c * sim_torque
      + d
  )


class _SimGravityTorquePrediction:
  """Predict gravity comp torques for the arm in any joint configuration."""

  def __init__(
      self,
      model_path: str,
      grav_comp_params: Mapping[int, Sequence[float]],
      arm_orientation: str = "upright",
  ):
    # JIT import of mujoco to not force mujoco install for piper_ros users that
    # don't use teach mode functionality.
    import mujoco

    self._model = mujoco.MjModel.from_xml_path(model_path)

    # Set gravity vector based on arm orientation using new system
    gravity = self._get_gravity_vector_for_orientation(arm_orientation)
    self._model.opt.gravity[:] = gravity
    print(f"Set gravity vector for {arm_orientation} orientation: {gravity}")

    self._data = mujoco.MjData(self._model)
    self._mj_forward_fn = mujoco.mj_forward

    self._grav_comp_params = grav_comp_params

    joint_names = ["joint1", "joint2", "joint3", "joint4", "joint5", "joint6"]
    self._joint_ids = [self._model.joint(name).id for name in joint_names]

  @staticmethod
  def _get_gravity_vector_for_orientation(orientation: str) -> list[float]:
    """Get gravity vector for arm mounting orientation using analytical transforms.

    Uses the ArmOrientation system and r2-transformations for proper analytical
    computation instead of hardcoded transformations.
    """

    # Get the orientation object and compute gravity analytically
    arm_orientation = piper_control.ArmOrientations.from_string(orientation)

    # Standard downward gravity in world frame
    world_gravity = np.array([0.0, 0.0, -9.81])

    # Rotate gravity into arm's coordinate frame using mounting quaternion
    gravity_vector = tr.quat_rotate(
        np.array(arm_orientation.mounting_quaternion), world_gravity
    )

    return np.asarray(gravity_vector).tolist()

  def predict(self, joint_angles: Sequence[float]) -> Sequence[float]:
    assert len(joint_angles) == len(self._joint_ids)

    for i, joint_id in enumerate(self._joint_ids):
      self._data.qpos[joint_id] = joint_angles[i]
      self._data.qvel[:] = 0.0

    # Propagate the changes through the simulation
    self._mj_forward_fn(self._model, self._data)
    result = [self._data.qfrc_bias[ji] for ji in self._joint_ids]

    for i, predicted_torque in enumerate(result):
      if i in self._grav_comp_params:
        model_input = np.array(predicted_torque)
        params = self._grav_comp_params[i]
        result[i] = grav_comp_adjustment_fn(model_input, *params)

    assert len(result) == len(self._joint_ids)
    return result


def _load_sampled_gravity(
    filename: str,
) -> dict[int, Sequence[GravityTorqueSample]]:
  with open(filename, "r", encoding="utf-8") as f:
    serialised = json.load(f)

  result = {}
  for se in serialised:
    joint_idx = se["joint_idx"]

    if joint_idx not in result:
      result[joint_idx] = []

    result[joint_idx].append(
        GravityTorqueSample(
            joint_configuration=np.array(se["joints_cfg"]),
            joint_idx=joint_idx,
            torque=se["grav_comp_torque"],
        )
    )

  return result


def _compute_gravity_model(
    piper_model_path: str,
    grav_torques_file_path: str,
    arm_orientation: str = "upright",
) -> _SimGravityTorquePrediction:
  """Given sampled grav comp torques generated by run_gather_data.py, output a
  gravity model that uses both MUJOCO and a learned residual.
  """

  # JIT import of scipy to not force it on piper_ros users that dont use teach
  # mode functionality.
  from scipy import optimize

  real_gravity = _load_sampled_gravity(grav_torques_file_path)
  sim_gravity = _SimGravityTorquePrediction(
      piper_model_path, {}, arm_orientation
  )

  per_joint_params = {}

  for joint_idx, samples in real_gravity.items():
    real_torques = []
    sim_torques = []

    for sample in samples:
      real_torques.append(sample.torque)

      desired_angles = list(sample.joint_configuration)
      model_torques = sim_gravity.predict(desired_angles)
      model_torque = model_torques[joint_idx]
      sim_torques.append(np.array(model_torque))

    sim_torques = np.array(sim_torques)

    opt_params = optimize.curve_fit(
        grav_comp_adjustment_fn,
        sim_torques,
        real_torques,
        p0=[0.0, 0.0, 1.0, 0.0],
    )[0]

    per_joint_params[joint_idx] = opt_params

  return _SimGravityTorquePrediction(
      piper_model_path, per_joint_params, arm_orientation
  )


class TeachController:
  """A controller that allows teach mode by commanding grav comp torques."""

  def __init__(
      self,
      robot: piper_interface.PiperInterface,
      controller: piper_control.MitJointPositionController,
      piper_model_path: str,
      grav_torques_file_path: str,
      arm_orientation: str = "upright",
  ):
    self._robot = robot
    self._controller = controller
    self._gravity_model = _compute_gravity_model(
        piper_model_path, grav_torques_file_path, arm_orientation
    )

  def step(self) -> None:
    cur_joints = self._robot.get_joint_positions()
    cur_vel = np.array(self._robot.get_joint_velocities())

    hover_torque = np.array(self._gravity_model.predict(cur_joints))

    # Stability torque acts to counteract joint movement. A dampener basically.
    stability_torque = -cur_vel * 1.0
    applied_torque = hover_torque + stability_torque

    self._controller.command_torques(list(applied_torque))
